#   实验六、银行家算法的模拟与实现

## 1、实验题目

银行家算法的模拟与实现

## 2、实验目的

 (1) 进一步了解进程的并发执行。
 (2) 加强对进程死锁的理解，理解安全状态与不安全状态的概念。
 (3) 掌握使用银行家算法避免死锁问题。

## 3、背景知识

（1）基本概念
* 死锁：多个进程在执行过程中，因为竞争资源会造成相互等待的局面。如果没有外力作用，这
些进程将永远无法向前推进。此时称系统处于死锁状态或者系统产生了死锁。
* 安全序列：系统按某种顺序并发进程，并使它们都能达到获得最大资源而顺序完成的序列为安
全序列。
* 安全状态：能找到安全序列的状态称为安全状态，安全状态不会导致死锁。
* 不安全状态：在当前状态下不存在安全序列，则系统处于不安全状态。

（2）银行家算法
银行家算法顾名思义是来源于银行的借贷业务，一定数量的本金要满足多个客户的借贷周转，
为了防止银行家资金无法周转而倒闭，对每一笔贷款，必须考察其是否能限期归还。
在操作系统中研究资源分配策略时也有类似问题，系统中有限的资源要供多个进程使用，必须保证得到的资源的进程能在有限的时间内归还资源，以供其它进程使用资源。如果资源分配不当，就会发生进程循环等待资源，则进程都无法继续执行下去的死锁现象。
当一进程提出资源申请时，银行家算法执行下列步骤以决定是否向其分配资源：
1）检查该进程所需要的资源是否已超过它所宣布的最大值。
2）检查系统当前是否有足够资源满足该进程的请求。
3）系统试探着将资源分配给该进程，得到一个新状态。
4）执行安全性算法，若该新状态是安全的，则分配完成；若新状态是不安全的，则恢复原状
态，阻塞该进程。

## 4、模块设计

本次代码设计包含俩个部分，第一个部分就是要检查进程所需要的资源是否超过最大值以及系统是否有足够的资源满足该进程的请求，第二个部分就是检查是否存在安全序列。

## 5、详细设计

### 5.1、数据结构
```c
int resource[N];		//总资源
int available[N];		//未分配的资源
int claim[M][N];		//进程声明的最大资源
int alloc[M][N];		//已经分配给进程的资源
int need[M][N];			//进程所需要的资源数量
```
由于在寻找安全序列的时候，未分配的资源和进程已经分配的资源是动态变化的，因此可以寻找一个替代和标记该进程的资源状态
```c
int List[M];			//存放安全序列
int Work[N];			//未分配资源的代替
int finish[M];			//标记是否被加入到安全序列中
```
函数说明
```c
void init() 			//初始化进程资源状况
void printstate()		//打印进程资源表
int safe()				//安全性检查算法
```
### 5.2、流程图

<img src=".\image\9.png" style="zoom: 50%; float: left;" />

### 5.3、算法思路

#### 5.3.1、安全性检查算法:

1. 初始化work:=available; finish:=0;
2. 寻找满足条件的i： A、finish[i]=0; B、need[i]≤work; 如果不存在，则转步骤4
3. work:=work+alloc[i]； finish[i]:=1；同时记录安全序列；转步骤2
4. 若对所有i,finish[i]=1,则系统处于安全状态， 否则处于不安全状态

#### 5.3.2、主程序：

1、首先进行特殊情况判断申请资源超过最大请求和资源不足
2、然后尝试进行资源分配
```c
alloc[n][0]+=x;
alloc[n][1]+=s;
alloc[n][2]+=j;
available[0]-=x;
available[1]-=s;
available[2]-=j;
for(int i=0;i<M;i++){
    for(int j=0;j<N;j++){
        need[i][j]=claim[i][j]-alloc[i][j];
         }
}
```
3. 系统进行安全性算法，检查此次分配后，系统是否还处于安全状态，若安全，把资源分配给进程p[i]；否则，恢复原来的资源分配状态，让进程p[i]等待。

## 6、实验结果分析

程序运行时初值：

<img src=".\image\10.png" style="zoom: 40%; float: left;" />

进程0申请R1和R3的一个资源，由于不存在安全序列，因此拒绝分配该资源给0号进程，恢复原来的资源分配状况：

<img src=".\image\11.png" style="zoom: 50%; float: left;" />

进程1申请R1和R3的一个资源，存在安全序列，允许分配该资源给进程1，并打印当前资源分配情况：

<img src=".\image\12.png" style="zoom: 50%; float: left;" />

## 7、小结与心得体会

这次实验模拟了操作系统的银行家算法，让我更加深刻的理解了进程死锁这一概念，也学习了如何进行死锁预防和死锁避免，而操作系统的银行家算法正是通过死锁避免来实现的，通过自己编写代码，大大加深了对于操作系统的银行家算法细节的理解，理解了如何通过安全性算法来检查系统状态是否安全。